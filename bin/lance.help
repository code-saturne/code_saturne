AIDE AU REMPLISSAGE DU FICHIER lance
====================================
====================================

L'utilisateur peut souhaiter ne pas utiliser le preprocesseur
  (uniquement pour les maillages *tlc *slc) : positionner
   SOLCOM=1
dans les autres cas positionner SOLCOM=0 en standard
ATTENTION : la lecture des maillages .slc et .tlc n'est
plus maintenue et est deconseillee.

               -------------------------------

Pour recoller des maillages, on donne des options supplementaires
  au preprocesseur :
   - preciser le nom des maillages entre " " dans 
     la variable MAILLAGE
   - preciser les options de recollement dans la variable 
     COMMANDE_RC. Il est preferable de preciser la couleur 
     des faces a recoller. Si c'est impossible, 
     il faut omettre l'option -color (mais le cout sera 
     superieur et la robustesse parfois moindre).La selection
     des faces peut se faire par d'autres moyens que la couleur
     (voir l'aide du preprocesseur par ecs -h). 
  Dans l'exemple ci-dessous, on cherche a recoller 
    les faces de couleur 3, 4 et 6 des maillages titi.des 
    et toto.unv.

    MAILLAGE="titi.des toto.unv"
    COMMANDE_RC="-j -color 3 4 6"

  S'il n'y a rien a recoller, on peut laisser vide 
    la variable COMMANDE_RC, soit COMMANDE_RC=.

               -------------------------------

Lorsque l'interface de Code_Saturne est utilisee, l'utilisateur
  specifie le nom du fichier parametrique au format xml dans 
  la variable PARAM. Le fichier doit etre localise dans le 
  repertoire DATA du cas.

               -------------------------------

Pour decouper en triangles les faces dont la distorsion (warp) est 
  superieure a un angle alpha en degres, on renseigne la variable 
  COMMANDE_DF. Par exemple, pour decouper au dela d'un angle de 0.01
  degres (c'est la valeur par defaut) : 

    COMMANDE_DF="-cwf 0.01"

  Si l'on ne souhaite rien decouper (par defaut), c'est-a-dire si 
    l'on souhaite utiliser le maillage tel qu'il a ete fourni par le 
    mailleur, on laisse vide la variable COMMANDE_DF soit COMMANDE_DF=

               -------------------------------

Pour traiter un cas periodique, il faut renseigner la variable 
  COMMANDE_PERIO pour le preprocesseur en precisant l'option -perio :

  Deux types de periodicite sont possibles : translation et rotation :
    Translation : -perio -trans tx ty tz 
      (tx,ty,tz): composantes du vecteur translation
    Rotation    : deux possibilites 
      - donnee de angle, direction et point invariant :
        -perio -rota -angle a -dir dx dy dz -invpt px py pz  
          a         : angle en degres (entre -180 et + 180)
          (dx,dy,dz): composantes d'un vecteur directeur 
                        de l'axe de rotation  
          (px,py,pz): composantes du point invariant de la rotation
      - donnee de matrice et point invariant :
        -perio -rota -matrix m11 m12 m13 m21 m22 m23 m31 m32 m33 -invpt px py pz  
          mij       : elements de la matrice de rotation par ligne
          (px,py,pz): composantes du point invariant de la rotation

  On peut composer translation et rotation : 
        -perio -trans tx ty tz -rota -angle a 
                                     -dir dx dy dz -invpt px py pz  
     ou -perio -trans tx ty tz -rota -matrix m11 m12 m13 
                                             m21 m22 m23 
                                             m31 m32 m33 
                                     -invpt   px py pz   
    La transformation composite est alors RoT (quel que soit l'ordre 
      dans lequel apparaissent rotation et translation dans la ligne 
      de commande).

  Le sens de la periodicite n'a pas d'importance (mais, dans le cas 
    d'une transformation composee RoT, R et T doivent naturellement
    etre coherentes entre elles).

  Il est preferable de preciser les faces concernees, en utilisant 
    les proprietes des faces, par exemple avec l'option -couleur (la 
    selection des faces peut se faire par d'autres moyens que la 
    couleur : voir l'aide du preprocesseur par ecs -h) : par exemple
      -perio -trans 10 0 0 -color 1 2

  On peut imposer jusqu'a trois periodicites (une par direction 
    d'espace) : on repete pour cela l'option -perio. par exemple 
    -perio -trans 10 0 0 -perio -trans 0 1 0 -perio -trans 0 0 1

  S'il n'y a pas de periodicite, on doit laisser vide 
    la variable COMMANDE_PERIO, c'est-a-dire : COMMANDE_PERIO=

  Exemple (le \ marque la continuation de la ligne de commande)
    COMMANDE_PERIO="-perio -trans -10.2 0 0 -color 2               \
                    -perio -rota -angle 90 -dir 0 0 1 -invpt 0 0 0 \
                           -color 3 4                              \
                    -perio -trans 0 1 0                            \ 
                           -rota -matrix 1 0  0                    \
                                         0 0 -1                    \
                                         0 1  0 -invpt 0 0 -0.2    "

               -------------------------------

Pour le couplage avec SYRTHES (un seul calcul fluide 
    et un seul calcul solide) il suffit de renseigner
    la variable COMMANDE_SYRTHES. S'il n'y a pas de couplage
    il suffit de la laisser vide.
  Dans l'exemple ci-dessous, on cherche a coupler les faces 
    de bord fluide de couleur 2 et 3

    COMMANDE_SYRTHES="-syrthes -color 2 3"

  Pour des couplages plus complexes, le script devra etre adapte. 

               -------------------------------

Le nom d'un eventuel fichier de donnees thermochimie peut etre 
    fourni dans DONNEES_THERMOCHIMIE. Par exemple : 
      DONNEES_THERMOCHIMIE="dp_FCP"

               -------------------------------

Le nom de fichiers de donnees utilisateur supplementaires a utiliser 
    peut etre fourni dans FICHIERS_DONNEES_UTILISATEUR
    Ces fichiers sont supposes etre dans le repertoire DATA

               -------------------------------

Le nom de fichiers resultats utilisateur supplementaires a rapatrier 
    peut etre fourni dans FICHIERS_RESULTATS_UTILISATEUR

               -------------------------------

L'option NOMBRE_DE_PROCESSEURS donne le nombre de processeurs (virtuels)
    a utiliser. Si la variable est laissee vide, le script la remplit
    automatiquement (pour les PC ou stations de travail NOMBRE_DE_PROCESSEURS
    est mis a 1, pour les clusters il correspond au nombre de processeurs
    reserves dans la carte ci-dessus).
    En cas de calcul a travers un gestionnaire de queue (CCRT ou cluster)
    NOMBRE_DE_PROCESSEURS est idealement egal au nombre de processeurs reels
    reserves dans les cartes ci-dessus. Il doit imperativement etre inferieur
    a ce nombre (un seul executable par processeur).
    Dans le cas d'un calcul en interactif (type calcul sur PC Linux),
    NOMBRE_DE_PROCESSEURS peut depasser le nombre de processeurs disponibles
    sur la machine (mais perte d'efficacite).
    Dans le cas d'un couplage avec SYRTHES a travers un gestionnaire de queue, 
    un processeur sera reserve pour SYRTHES et le nombre de processeurs utilises
    par le noyau sera donc egal a nproc_noy = NOMBRE_DE_PROCESSEURS-1.
    


Si l'on souhaite specifier des machines distantes, on peut completer  
      la chaine optionnelle LISTE_PROCESSEURS. 
    Ce n'est pas recommande car les performances du reseau sont 
      generalement tres mauvaises.
    Deux exemples simples :
    LISTE_PROCESSEURS="machine1 cpu=nb_cpu1 user=userid1 & machine2 cpu=nb_cpu2 user=userid2")
    LISTE_PROCESSEURS="machine1  & machine2")
    Le & separe deux machines. Les champs sont les suivants : 
      machine1 et machine2 designent le nom des machines 
         (obtenu par la commande hostname) 
         par exemple : chi80xx.der.edf.fr 
      nb_cpu1 et nb_cpu2 designent le nombre de processeurs des 
         machines machine1 et machine2 
         par exemple, sur un pc biprocesseur : cpu=2 
      userid1 et userid2 designent le login de l'utilisateur sur les
         machines machine1 et machine2 
    Les informations cpu= et user= sont optionnelles.  
    La machine courante (celle depuis laquelle est execute le script)
      sera obligatoirement utilisee. 
    Les machines selectionnees doivent etre en nfs et de la meme 
      architecture (toutes HP ou toutes IRIX, toutes Linux...).

               -------------------------------

La variable CS_TMP_PREFIX permet a l'utilisateur de specifier le
    repertoire temporaire utilise pour le calcul. Si CS_TMP_PREFIX est
    vide, le code utilise le repertoire par defaut (qui depend de
    l'architecture). Si l'utilisateur a specifie une valeur, le
    repertoire temporaire sera
    RUN=$CS_TMP_PREFIX/tmp_Saturne/$ETUDE.$CAS.$DATE

Specifier CS_TMP_PREFIX peut etre utile par exemple sur station pour
    profiter de la presence d'un disque local de grande capacite
    CS_TMP_PREFIX=/local00/users/`whoami` (par exmple)
    Sur Nickel/Chrome, le repertoire par defaut est TMPDIR, detruit
    automatiquement apres chaque execution. Si l'utilisateur a besoin*
    de conserver le repertoire temporaire apres execution (debugage)
    il doit aussi changer CS_TMP_PREFIX
    (CS_TMP_PREFIX=$SCRATCHDIR par exemple)

               -------------------------------

Les options OPTIMISATION, LISTE_LIB_SAT et OPTION_LIB_EXT sont 
    des options plus avancees, a usage des developpeurs.

  OPTIMISATION permet de specifier l'optimisation selectionnee 
    (LO, DBG, EF, PROF, ...). Par defaut, les choix
    standards de Code_saturne sont utilises. Ce parametre est 
    surtout utile en developpement pour utiliser les bibliotheques
    sans optimisation, en debug, etc. Il est donc conseille de 
    conserver la valeur par defaut (chaine vide).
    Ce mot cle est ignore si LISTE_LIB_SAT n'est pas vide.
    Une liste des valeurs d'OPTIMISATION et une explication est
    fournie par makehelp (voir OPT=).

  LISTE_LIB_SAT permet de specifier la liste exhaustive des 
    bibliotheques de Code_saturne a utiliser lors de l'edition des
    liens. Par defaut, les bibliotheques de tous les modules sont 
    prises en compte. Ce parametre est surtout utile en 
    developpement. Il est donc conseille de conserver la valeur 
    par defaut (chaine vide). Exemple : 
      LISTE_LIB_SAT="libsaturneBASE.a libsaturneCFBL.a libsaturneCOGZ.a \
                     libsaturneCPLV.a libsaturneELECDBG.a libsaturneFUEL.a \
                     libsaturneLAGR.a libsaturneRAYT.a libsaturneMATI.a"
    Ce mot cle est prioritaire sur OPTIMISATION.
    Une explication est fournie par makehelp (voir MOD=).

  OPTION_LIB_EXT permet de specifier des librairies externes a
    rajouter pour l'edition des liens. Dans ce cas, il faut
    specifier l'integralite de la commande a passer au linker.
    Par exemple :
    OPTION_LIB_EXT="-L/home/saturne/opt/bidon/lib -lbidon"

  VALGRIND permet de lancer le noyau avec VALGRIND si 
    ce software de verification de la memoire est disponible (en 
    pratique sous Linux). Pour l'activer :   
      VALGRIND=valgrind
    avec eventuellement des options specifiques, comme par exemple
      VALGRIND="valgrind --tool=memcheck"
    Dans le cas ou valgrind n'est pas trouve automatiquement dans 
    le PATH, specifier le chemin d'acces complet.

  ARG_CS_VERIF permet d'activer des tests elementaires sur la
    qualite du maillage et sur les performances de la machine.
    ="-q 0" : criteres de qualite du maillage
    ="-q 1" : test de calcul du gradient de sin(x+2y+3z) en IMRGRA=0
    ="-q 2" : test de calcul du gradient de sin(x+2y+3z) en IMRGRA=1
    ="-q 3" : test de calcul du gradient de sin(x+2y+3z) en IMRGRA=2
    ="-q 4" : test de calcul du gradient de sin(x+2y+3z) en IMRGRA=3
    ="-q 5" : test de calcul du gradient de sin(x+2y+3z) en IMRGRA=4
    ="--benchmark" : performances des operations elementaires
    ="--benchmark --mpitrace" : idem que benchmark avec operations
                                effectuees une seule fois pour traces
                                MPI legeres
    En mode de verification, le code ne necessite aucun fichier
    parametrique ni aucun sous-programme utilisateur.

  ARG_CS_OUTPUT permet de gerer les redirections de listings. 
    L'option "--log" permet de choisir la redirection des sorties
    pour un calcul monoprocesseur ou pour le processeur de rang 0
    d'un calcul en parallele.
    "--log 0" sorties dirigees vers la sortie standard
    "--log 1" sorties redirigees vers un fichier "listing"
      (comportement par defaut)
    L'option "--logp n" permet de choisir la redirection des sorties
    pour les processeurs de rang 1 a N-1 d'un calcul en parallele sur
    N processeurs :
    "--logp -1" shunte les sorties des processeurs de rang superieur a 1
      (comportement par defaut)
    "--logp 0" ne fait aucune redirection. Toutes les impressions vont
      vers la sortie standard (utile en debugage si chaque processeur
      tourne dans un terminal different)
    "--logp 1" redirige les sorties des processeurs de rang 1 a N-1 vers
      les fichiers listing_n0002 a listing_n<N>.
    Les options --log et --logp peuvent etre specifiees separement ou
    ou ensemble dans la variable ARG_CS_OUTPUT.

  ECHOCOMM permet de faire afficher les echanges preprocesseur noyau 
    SYRTHES. Utile uniquement en cas de probleme de communication. 
    Si on souhaite activer cette possibilite, on affecte 
    une valeur entiere strictement positive a ECHOCOMM. A chaque 
    communication, on affichera les ECHOCOMM premiers et derniers 
    elements du message (caracteres, entieres, reels).
    Par defaut, on conserve la chaine vide. 
    Exemple d'activation raisonnable : 
      ECHOCOMM="10"

  PILOTAGE_ADAPTATION permet d'utiliser les fonctionnalites d'adaptation
    de maillage, en couplage avec le logiciel HOMARD.
    Si la variable est absente, ou si elle est vide, c'est un calcul
    sans adaptation.
    Pour activer l'adaptation, on remplira cette variable PILOTAGE_ADAPTATION
    avec le nom du fichier contenant les directives de pilotage.
    Pour connaitre la syntaxe de ce fichier de pilotage, on fera :
    PILOTAGE_ADAPTATION=-help et on lancera ce script lance.
    CETTE FONCTIONNALITE EST ENCORE EN DEVELOPPEMENT
